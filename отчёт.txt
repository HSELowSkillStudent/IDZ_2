Отчет.
Студент Спиидонов Дмитрий Вячеславович
Группа БПИ-214
Вариант 22
Условие задачи:
    Разработать программу, вычисляющую число вхождений различных знаков препинания в заданной ASCII-строке.
Задание выполнено с расчетом на оценку 8

На 4 балла:
    * В файлах main.c и func.c хранятся программы на языке C.
    * Получены ассемблерные программы(main.s и func.s) откомпилированная при помощи команды в командной строке:
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none main.c
      В файлы main.s и func добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C
    * В полученном ассемблерном коде не использовались макросы, поэтому удалять было нечего.
    * Итоговая ассемблерная программа откоплилирована и скомпонована командой
        gcc main.s func.s -o s
      Программа на языке C откоплилирована и скомпонована командой
        gcc main.c -o c
    * Полное тестовое покрытие(так же представлено в файле tests.txt):
        input:

        output:
        
        
        
        input:
        .
        output:
        <.>: 1
        
        
        input:
        .,
        output:
        <.>: 1
        <,>: 1
        

        input:
        aaaabbb
        output:



        input:
        .,;:!?-()'"
        output:
        <.>: 1
        <,>: 1
        <;>: 1
        <:>: 1
        <!>: 1
        <?>: 1
        <->: 1
        <(>: 1
        <)>: 1
        <'>: 1
        <">: 1



        input:
                    
        output:
    * Результат тестовых прогонов программы на C и Ассемблере хранится в фотографиях в папке /4
        
        
На 5 баллов:
    * Программа реализована с использованием функций с передачей данных через параметры
    * В функции random_input используются локальные переменные:
        size_t i
	
      В функции file_input используются локальные переменные:
        FILE *input_file
        FILE *output_file
	
      В функции countSignes используются локальные переменные:
        char a
        size_t i
        
    * В полученные ассемблерные программы добавлены комментарии, описывающие передачу фактических парметров, перенос возвращаемого результата. Описана связь между параметрами языка C и регистрами(файлы main.s и func_n.s)
    

На 6 баллов:
    * В функции countSignes(файл func_n.s) минимизировано количество обращений к памяти путем максимального использования регистров процессора, добавлены комментарии:
	result.point         - rcx           # .
	result.comma         - r8            # ,
	result.semicolon     - r9            # ;
	result.colon         - r10           # :
	result.exclamation   - r11           # !
	result.question      - r12           # ?
	result.dash          - r13           # -
	result.left_bracket  - r14           # (
	result.right_bracket - r15           # )
	result.single_quote  - rbx           # '
	на result.double_quote (# ") регистров не хватило :(
    * На тестовом покрытии измененная программа показала те же результаты, что и прошлые программы. Результат тестовых прогонов программы хранится в фотографии в папке /6
        


На 7 баллов:
    * Функции countSignes, outputStruct и структура struct SIGN{...}result хранятся отдельно в файле func.c
    * Реализовано задание текстовых файлов для ввода и вывода (ключ -f)
    * Изменений произойти не могло, т.к. программа изначально была реализована данным способом
    * Изначально программа, написанная на Си, используюет функцию, хранящуюся в файле func.c, однако после компиляции файла в ассемблерный код(main.s) участок кода с функцией удален, в дальнейшем "импорт" будет происходить путем использованием команды:
        gcc main.s func_n.s(или func.s) -o res
    * Си файл преобразован в ассемблерный код командой
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none func.c
    * Запуск программы происходит из командой строки командой(при помощи ключа)
        ./res -f <имя файла 1> <имя файла 2>
    * Примечание: на моей системе не работал fopen без указание полного пути до файла


На 8 баллов:
    * В программе(файл main.c) реализовано 4 возможных вида задания массива А:
        1) Через консоль(как в программе на 4 балла) - передача без аргументов
        2) Через файлы - первым аргументом идет флаг -f(или --file), вторым и третьим аргументами идут имена файлов, с которым будет работать программа(читать данные из первого файла и возвращать результат во второй)
        3) Через аргументы переданные в командную стркоу - для этого достаточно вместо флагов сразу передать элементы массива А
        4) Через генератор случайных наборов данных - для этого первым аргументом идет флаг -r(или --random), вторым аргументом идет размер массива А
    * Также добавлен ключ -h(или --help), который выдает список аргументов, которые может обрабатывать командная строка
    * Для реализации пункта 3 создана отдельная папка secondPart. Дальнейшая работа проходит в этой папке
    * Из файла main.c получен ассемблерный код(файл main.s) командой 
        gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none main.c
    * В полученном файле был добавлен импорт функции countSignes(функция из пункта на 6) и последнее использование функции countSignesNO заменено на функцию countSignes
    * Полученная программа была скомпилирована в исполняемый файл и запущена. Результат работы представлен на фотографиях, которая хранится в папке /8_second
